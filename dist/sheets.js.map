{"version":3,"sources":["webpack://sheets/webpack/universalModuleDefinition","webpack://sheets/webpack/bootstrap","webpack://sheets/./src/Cell.js","webpack://sheets/./src/ColumnHeader.js","webpack://sheets/./src/ColumnHeaderRow.js","webpack://sheets/./src/Context.js","webpack://sheets/./src/Row.js","webpack://sheets/./src/RowHeader.js","webpack://sheets/./src/ScreenComponent.js","webpack://sheets/./src/ScrollBar.js","webpack://sheets/./src/Sheet.js","webpack://sheets/./src/constants.js","webpack://sheets/./src/util.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;AClFA;AACA;AAC2B;AACZ;;AAEf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;;AAEA;AACA;;AAEA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,yBAAyB;AACzB,qDAAqD;AACrD,oDAAoD;AACpD,2CAA2C,qCAAqC;AAChF,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;ACvSA;AACa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;AC5DA;AACA;AACkD;;AAElD;AACA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,kBAAkB,+BAA+B;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,+BAA+B;AAC5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B,6BAA6B;AAC7B,gCAAgC;AAChC,8BAA8B;AAC9B;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;AC5IA;AACA;AACA;AACkD;;AAElD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,uBAAuB;AACpD;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;;AAEA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACzGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC1BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;ACvPA;AACA;AACA;AACA;AACkD;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,yCAAyC,6BAA6B;AACtE;AACA;;AAEA;;AAEA,yCAAyC,6BAA6B;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA,6BAA6B,sBAAsB;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yCAAyC,6BAA6B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;;;;;;;;;;;;;;;;;ACzRA;AACA;AACA;;;;;;;;;;;;;;;ACFA;AAAA,2CAA2C;;AAE3C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B,OAAO;AAClC;AACA;;AAEA;AACA","file":"sheets.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sheets\"] = factory();\n\telse\n\t\troot[\"sheets\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/Sheet.js\");\n","import ScreenComponent from './ScreenComponent';\nimport Context from './Context';\nimport { ROW_HEADER_WIDTH } from './constants';\nimport { aToI } from './util';\n\nclass Cell extends ScreenComponent {\n  constructor(index, rowIndex, sheet, x, y, width, height, options) {\n    super(sheet, x, y, width, height);\n\n    this.index = index;\n    this.rowIndex = rowIndex;\n    this.text = \"\";\n\n    Object.assign(this, {\n      color: 'black',\n      backGroundColor: 'white',\n      borderColor: 'darkGray',\n      borderWidth: 1\n    }, options);\n\n    this.dependentCells = [];\n  }\n\n  registerDependentValueCell(cell) {\n    this.dependentCells.push(cell);\n  }\n\n  updateValue(value) {\n    this.value = value;\n\n    //TODO: Should nulls be displayed the same as undefined (i.e. blank)?\n    if (value === undefined || value === null) {\n      return;\n    }\n\n    const getIndividualArgValue = (arg) => {\n      let colAlphaMatch = arg.match(/[A-Z]+/);\n\n      if (/[A-Z]+/.test(arg)) {\n        //Cell reference\n        let colAlpha = colAlphaMatch[0];\n        let col = aToI(colAlpha);\n        let row = arg.match(/\\d+/)[0] - 1;\n\n        let cell = this.sheet.getCell(row, col);\n\n        return cell.value;\n      }\n      else {\n        //Number literal (we assume)\n        return arg;\n      }\n    };\n\n    if (value.indexOf(\"=\") == 0) {\n      try {\n        let functionName = value.substr(1).split('(')[0];\n        let args = value.substr(1).split('(')[1].replace(')', '').split(',');\n  \n        let argValues = [];\n  \n        for (let i = 0; i < args.length; i++) {\n          let arg = args[i].trim();\n  \n          if (arg.indexOf(\":\") !== -1) {\n            let rangeIndexes = arg.split(':');\n  \n            //TODO: This is not actually a range right now\n            for (let j = 0; j < rangeIndexes.length; j++) {\n              argValues.push(getIndividualArgValue(rangeIndexes[j]));\n            }\n          }\n          else {\n            argValues.push(getIndividualArgValue(arg));\n          }\n        }\n        functionName = functionName.toUpperCase();\n        let result = formulajs[functionName].apply(null, argValues);\n  \n        this.text = result;\n      } catch (error) {\n        console.error(error);\n        alert('Formula Error');\n        throw error;\n      }\n    }\n    else {\n      this.text = value;\n    }\n\n    if (!this.isTextBufferInitialized) {\n      this.textBufferCanvas = document.createElement('canvas');\n\n      this.textBufferContext = new Context(this.textBufferCanvas, {\n        width: this.width,\n        height: this.height\n      });\n\n      this.isTextBufferInitialized = true;\n    }\n\n    this.isNumeric = this.text && /^\\d*(\\.\\d+)?$/.test(this.text);\n\n    this.repaint();\n  }\n\n  repaint() {\n    if (this.isTextBufferInitialized) {\n      this.textBufferContext = new Context(this.textBufferCanvas, {\n        width: this.width,\n        height: this.height\n      });\n\n      this.textBufferContext.clear();\n\n      this.textBufferContext.drawRect(0, 0, this.width, this.height, {\n        fillColor: this.isSelected ? '#c9e2f9' : this.backGroundColor,\n        borderColor: this.borderColor,\n        borderWidth: this.borderWidth\n      });\n\n      //TODO: Formatting\n\n      this.textBufferContext.drawText(this.text, this.isNumeric ? this.width : 0, this.height / 2, {\n        font: this.height * 0.8 + 'px Sans',\n        color: this.color,\n        align: this.isNumeric ? 'end' : 'start',\n        baseLine: 'middle'\n      });\n    }\n\n    if (this.isEditing) {\n      if (this.width > 4) {\n        this.inputElement.width(this.width - 4);\n      }\n      else {\n        this.blur();\n      }\n    }\n  }\n\n  draw() {\n    if (!this.isTextBufferInitialized) {\n      this.sheet.context.drawRect(this.sheet.scrollX + this.x, this.sheet.scrollY + this.y, this.width, this.height, {\n        fillColor: this.isSelected ? '#c9e2f9' : this.backGroundColor,\n        borderColor: this.borderColor,\n        borderWidth: this.borderWidth\n      });\n    }\n    else {\n      this.repaint();\n      this.sheet.context.drawImage(this.textBufferCanvas, this.x + this.sheet.scrollX, this.y + this.sheet.scrollY, this.width, this.height);\n    }\n\n    if (this.isEditing) {\n      if (this.sheet.scrollX + this.x < ROW_HEADER_WIDTH || this.sheet.scrollX + this.x > this.sheet.width - this.width || this.sheet.scrollY + this.y < 20 || this.sheet.scrollY + this.y > this.sheet.height - this.height) {\n        this.inputElement.hide();\n      }\n      else {\n        this.inputElement.show();\n        this.inputElement.css(\"left\", this.sheet.scrollX + this.x + \"px\");\n        this.inputElement.css(\"top\", this.sheet.scrollY + this.y + \"px\");\n        this.inputElement.focus();\n      }\n    }\n  }\n\n  blur() {\n    this.isSelected = false;\n\n    if (this.isEditing) {\n      this.isEditing = false;\n      try {\n        this.updateValue(this.inputElement.val());\n      } catch (error) {\n        console.error(error);\n      }\n      this.inputElement.remove();\n      this.inputElement = undefined;\n    }\n  }\n\n  mouseDown(x, y) {\n    this.sheet.startMultiSelect();\n    this.sheet.updateSelection(this.rowIndex, this.index);\n  }\n\n  mouseMove(x, y) {\n    if (this.sheet.isMultiSelecting) {\n      this.sheet.updateSelection(this.rowIndex, this.index);\n    }\n  }\n\n  mouseUp(x, y) {\n    if (this.sheet.multiSelectSize() == 1) {\n      this.edit();\n      this.sheet.clearMultiSelect();\n    }\n\n    this.sheet.endMultiSelect();\n  }\n\n  mouseClick(x, y) {\n\n  }\n\n  edit() {\n    this.sheet.deselectAllCells();\n\n    this.isEditing = true;\n    this.inputElement = $(\"<input>\", {\n      type: \"text\",\n      id: \"cell-input\",\n      style:\n        \"text-align: \" + (this.isNumeric ? \"right\" : \"left\") + \";\" +\n        \"position: fixed;\" +\n        \"left: \" + this.sheet.scrollX + this.x + \"px;\" +\n        \"top: \" + this.sheet.scrollY + this.y + \"px;\" +\n        \"width: \" + (this.width - 4) + \"px; height: \" + (this.height - 4) + \"px;\"\n    });\n\n    $(\"body\").append(this.inputElement);\n\n    let dirty = false;\n\n    this.inputElement.val(this.value);\n\n    this.inputElement.keydown((e) => {\n      let keyCode = e.keyCode || e.which;\n\n      //TODO: auto scroll if moving to cell would make the input disappear\n\n      if (keyCode === 13) {\n        this.updateValue(this.inputElement.val());\n\n        if (this.isNumeric) {\n          this.inputElement.css(\"text-align\", this.isNumeric ? \"right\" : \"left\")\n        }\n        //Enter, go to next row\n        this.sheet.rows[this.rowIndex + (e.shiftKey ? -1 : 1)].cells[this.index].edit();\n      }\n      else if (keyCode === 9) {\n        //Tab, go to next column\n        this.sheet.rows[this.rowIndex].cells[this.index + (e.shiftKey ? -1 : 1)].edit();\n        e.preventDefault();\n      }\n      else if (keyCode === 37) {\n        //Left arrow\n        if (!dirty) {\n          this.sheet.rows[this.rowIndex].cells[this.index - 1].edit();\n        }\n      }\n      else if (keyCode === 39) {\n        //Right arrow\n        if (!dirty) {\n          this.sheet.rows[this.rowIndex].cells[this.index + 1].edit();\n        }\n      }\n      else if (keyCode === 38) {\n        //Up arrow\n        this.sheet.rows[this.rowIndex - 1].cells[this.index].edit();\n      }\n      else if (keyCode === 40) {\n        //Down arrow\n        this.sheet.rows[this.rowIndex + 1].cells[this.index].edit();\n      }\n      else if ((keyCode === 46 /* Delete */ || keyCode === 8 /* Backspace */) && !dirty) {\n        this.inputElement.val(undefined);\n        this.updateValue(undefined);\n      }\n    });\n\n    this.inputElement.keyup((e) => {\n      let keyCode = e.keyCode || e.which;\n\n      if (keyCode !== 13 && keyCode !== 9 && keyCode !== 37 && keyCode !== 39 && keyCode !== 38 && keyCode !== 40) {\n        dirty = true;\n\n        // this.updateValue(this.inputElement.val());\n\n        // if (this.isNumeric) {\n        //   this.inputElement.css(\"text-align\", this.isNumeric ? \"right\" : \"left\")\n        // }\n      }\n    });\n\n    this.inputElement.bind('paste', (e) => {\n      var pastedData = e.originalEvent.clipboardData.getData('text');\n\n    });\n\n    this.inputElement.focus();\n  }\n}\n\nexport default Cell;\n","import ScreenComponent from './ScreenComponent';\nimport {iToA} from './util';\n\nclass ColumnHeader extends ScreenComponent {\n  constructor(index, sheet, x, y, width, height, options) {\n    super(sheet, x, y, width, height, options);\n\n    this.index = index;\n\n    Object.assign(this, {\n      color: 'black',\n      backGroundColor: 'lightGray',\n      borderColor: 'darkGray',\n      borderWidth: 1\n    }, options);\n\n    this.updateText(iToA(this.index));\n  }\n\n  isVisibleOnScreen() {\n    return !(this.x + this.sheet.scrollX + this.width < 0 || this.x + this.sheet.scrollX > this.sheet.width ||\n      this.y + this.height < 0 || this.y  > this.sheet.height);\n  }\n\n  updateText(value) {\n    this.text = value;\n\n    this.repaint();\n  }\n\n  repaint() {\n    this.textBufferCanvas = document.createElement('canvas');\n    this.textBufferContext = this.textBufferCanvas.getContext('2d');\n\n    this.textBufferCanvas.width = this.width * 2;\n    this.textBufferCanvas.height = this.height * 2;\n    this.textBufferCanvas.style.width = this.width;\n    this.textBufferCanvas.style.height = this.height;\n\n    this.textBufferContext.scale(2, 2);\n\n    this.textBufferContext.font = this.height * 0.8 + 'px Sans';\n    this.textBufferContext.fillStyle = this.color;\n    this.textBufferContext.textAlign = 'center';\n    this.textBufferContext.textBaseline = 'middle';\n\n    this.textBufferContext.fillText(this.text, this.width / 2, this.height / 2);\n  }\n\n  draw() {\n    this.sheet.context.drawRect(this.x + this.sheet.scrollX, this.y, this.width, this.height, {\n      fillColor: this.backGroundColor,\n      borderColor: this.borderColor,\n      borderWidth: this.borderWidth\n    });\n\n    this.sheet.context.drawImage(this.textBufferCanvas, this.x + this.sheet.scrollX, this.y, this.width, this.height);\n  }\n}\n\nexport default ColumnHeader;\n","import ScreenComponent from './ScreenComponent';\nimport ColumnHeader from './ColumnHeader';\nimport {CELL_WIDTH, CELL_HEIGHT, ROW_HEADER_WIDTH} from './constants';\n\nclass ColumnHeaderRow extends ScreenComponent {\n  constructor(sheet, x, y, colCount, options) {\n    super(sheet, x, y, ROW_HEADER_WIDTH + colCount * CELL_WIDTH, CELL_HEIGHT);\n\n    this.columnHeaders = [];\n\n    let headerX = ROW_HEADER_WIDTH;\n\n    for(let i = 0; i < colCount; i++) {\n      this.columnHeaders.push(new ColumnHeader(i, sheet, headerX, this.y, CELL_WIDTH, CELL_HEIGHT, {\n        color: 'black',\n        backGroundColor: 'lightGray',\n        borderColor: 'black',\n        borderWidth: 1\n      }));\n\n      headerX += CELL_WIDTH;\n    }\n  }\n\n  draw() {\n    for(let i = 0; i < this.columnHeaders.length; i++) {\n      const columnHeader = this.columnHeaders[i];\n\n      if(columnHeader.isVisibleOnScreen()) {\n        columnHeader.draw();\n      }\n    }\n  }\n\n  resizeCol(colIndex, newWidth) {\n    let columnHeader = this.columnHeaders[colIndex];\n    let oldWidth = columnHeader.width;\n\n    columnHeader.width = newWidth;\n    columnHeader.repaint();\n\n    for(let i = colIndex + 1; i < this.columnHeaders.length; i++) {\n      this.columnHeaders[i].x += (newWidth - oldWidth);\n    }\n  }\n\n  mouseMove(x, y) {\n    if(this.isResizing) {\n      let xDelta = x - this.resizeStartX;\n\n      this.sheet.resizeCol(this.resizeHeader.index, this.resizeStartWidth + xDelta);\n    }\n    else {\n      for(let i = 0; i < this.columnHeaders.length; i++) {\n        let columnHeader = this.columnHeaders[i];\n\n        if(x > columnHeader.x + this.sheet.scrollX + columnHeader.width - 5 && x < columnHeader.x + this.sheet.scrollX + columnHeader.width + 5) {\n          document.body.style.cursor = 'col-resize';\n          this.resizeHeader = columnHeader;\n        }\n      }\n    }\n  }\n\n  mouseDown(x, y) {\n    if(this.resizeHeader) {\n      this.resizeStartX = x;\n      this.resizeStartWidth = this.resizeHeader.width;\n      this.isResizing = true;\n    }\n  }\n\n  mouseUp(x, y) {\n    this.resizeHeader = undefined;\n    this.isResizing = false;\n  }\n\n  mouseClick(x, y) {\n    for(let i = 0; i < this.columnHeaders.length; i++) {\n      if(this.columnHeaders[i].isCollision(x, y)) {\n        this.columnHeaders[i].mouseClick(x, y);\n      }\n    }\n  }\n}\n\nexport default ColumnHeaderRow;\n","\nclass Context {\n  constructor(target, options) {\n    options = Object.assign({\n      onMouseMove: (x, y) => {},\n      onMouseDown: (x, y) => {},\n      onMouseUp: (x, y) => {},\n      onMouseClick: (x, y) => {},\n      onScroll: (dx, dy) => {},\n      useCanvasScroll: true\n    }, options);\n\n    target.width = options.width * 2;\n    target.height = options.height * 2;\n    target.style.width = options.width + \"px\";\n    target.style.height = options.height + \"px\";\n    this.target = target;\n    this.ctx = target.getContext(\"2d\");\n    this.ctx.scale(2, 2);\n\n    var self = this;\n\n    const getMouseCoords = function (e) {\n  \t\tvar rect = self.ctx.canvas.getBoundingClientRect();\n\n  \t\treturn {\n  \t\t\tx: e.clientX - rect.left,\n  \t\t\ty: e.clientY - rect.top\n  \t\t};\n  \t};\n\n    this.ctx.canvas.onmousemove = function(e) {\n      var coords = getMouseCoords(e);\n    \toptions.onMouseMove(coords.x, coords.y);\n      e.preventDefault();\n    };\n\n    this.ctx.canvas.onmousedown = function (e) {\n    \tvar coords = getMouseCoords(e);\n    \toptions.onMouseDown(coords.x, coords.y);\n      e.preventDefault();\n    };\n\n    this.ctx.canvas.onmouseup = function (e) {\n    \tvar coords = getMouseCoords(e);\n    \toptions.onMouseUp(coords.x, coords.y);\n      e.preventDefault();\n    };\n\n    this.ctx.canvas.onclick = function (e) {\n    \tvar coords = getMouseCoords(e);\n    \toptions.onMouseClick(coords.x, coords.y);\n      e.preventDefault();\n    };\n\n    this.ctx.canvas.onmousewheel = function(e) {\n      if(options.useCanvasScroll){\n        options.onScroll(e.deltaX, e.deltaY);\n        e.preventDefault();\n      }\n    };\n\n    // this.textBufferCanvas = document.createElement('canvas');\n    // this.textBufferContext = this.textBufferCanvas.getContext('2d');\n  }\n\n  drawLine(points, options) {\n    options = Object.assign({\n      width: 1,\n      color: 'black',\n      cap: 'square',\n      lineJoin: 'miter'\n    }, options);\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(points[0][0], points[0][1]);\n    for(let i = 1; i < points.length; i++) {\n      this.ctx.lineTo(points[i][0], points[i][1]);\n    }\n    this.ctx.lineWidth = options.width;\n    this.ctx.strokeStyle = options.color;\n    this.ctx.lineCap = options.cap;\n    this.ctx.lineJoin = options.lineJoin;\n    this.ctx.stroke();\n  }\n\n  drawRect(x, y, width, height, options) {\n    options = Object.assign({\n      borderWidth: 1,\n      borderColor: undefined,\n      fillColor: undefined\n    }, options);\n\n    this.ctx.beginPath();\n\n    if(options.fillColor) {\n      this.ctx.fillStyle = options.fillColor;\n    }\n\n    if(options.borderColor) {\n      this.ctx.lineWidth = options.borderWidth;\n      this.ctx.strokeStyle = options.borderColor;\n    }\n\n    this.ctx.rect(x, y, width, height);\n\n    if(options.fillColor) {\n      this.ctx.fill();\n    }\n\n    if(options.borderColor) {\n      this.ctx.stroke();\n    }\n  }\n\n  drawText(text, x, y, options) {\n    options = Object.assign({\n      font: '14px Sans',\n      color: 'white',\n      align: 'center',\n      baseLine: 'middle'\n    }, options);\n\n    this.ctx.font = options.font;\n    this.ctx.fillStyle = options.color;\n    this.ctx.textAlign = options.align;\n    this.ctx.textBaseline = options.baseLine;\n\n    this.ctx.fillText(text, x, y);\n  }\n\n  drawImage(img, x, y, width, height) {\n    this.ctx.drawImage(img, x, y, width, height);\n  }\n\n  clear() {\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n  }\n}\n\nexport default Context;\n","import ScreenComponent from './ScreenComponent';\nimport RowHeader from './RowHeader';\nimport Cell from './Cell';\nimport {CELL_WIDTH, CELL_HEIGHT, ROW_HEADER_WIDTH} from './constants';\n\nclass Row extends ScreenComponent {\n  constructor(index, sheet, x, y, colCount, options) {\n    //TODO: Calculate width, also update width on column resize\n    //TODO: Pass in width and height as options\n    super(sheet, x, y, ROW_HEADER_WIDTH + colCount * CELL_WIDTH, CELL_HEIGHT);\n\n    this.index = index;\n\n    //Header cell\n    this.rowHeader = new RowHeader(0, index, sheet, 0, this.y, ROW_HEADER_WIDTH, CELL_HEIGHT, {\n      color: 'black',\n      backGroundColor: 'lightGray',\n      borderColor: 'black',\n      borderWidth: 1\n    });\n\n    //Data cells\n    this.cells = [];\n\n    let cellX = ROW_HEADER_WIDTH;\n\n    for(let i = 0; i < colCount; i++) {\n      this.cells.push(new Cell(i, index, sheet, cellX, this.y, CELL_WIDTH, CELL_HEIGHT, options));\n      cellX += CELL_WIDTH;\n    }\n  }\n\n  draw() {\n    for(let i = 0; i < this.cells.length; i++) {\n      const cell = this.cells[i];\n\n      if(cell.isVisibleOnScreen()) {\n        cell.draw();\n      }\n    }\n\n    this.rowHeader.draw();\n  }\n\n  resizeCol(colIndex, newWidth) {\n    let cell = this.cells[colIndex]\n    let oldWidth = cell.width;\n\n    cell.width = newWidth;\n    cell.repaint();\n\n    for(let i = colIndex + 1; i < this.cells.length; i++) {\n      this.cells[i].x += (newWidth - oldWidth);\n    }\n  }\n\n  mouseDown(x, y) {\n    for(let i = 0; i < this.cells.length; i++) {\n      if(this.cells[i].isCollision(x, y)) {\n        this.cells[i].mouseDown(x, y);\n      }\n    }\n  }\n\n  mouseMove(x, y) {\n    for(let i = 0; i < this.cells.length; i++) {\n      if(this.cells[i].isCollision(x, y)) {\n        this.cells[i].mouseMove(x, y);\n      }\n    }\n  }\n\n  mouseUp(x, y) {\n    for(let i = 0; i < this.cells.length; i++) {\n      if(this.cells[i].isCollision(x, y)) {\n        this.cells[i].mouseUp(x, y);\n      }\n    }\n  }\n\n  mouseClick(x, y) {\n    for(let i = 0; i < this.cells.length; i++) {\n      if(this.cells[i].isCollision(x, y)) {\n        this.cells[i].mouseClick(x, y);\n      }\n    }\n  }\n\n  deselectAllCells() {\n    for(let i = 0; i < this.cells.length; i++) {\n      this.cells[i].blur();\n    }\n  }\n\n  updateSelection(minColIndex, maxColIndex) {\n    for(let i = minColIndex; i <= maxColIndex; i++) {\n      this.cells[i].isSelected = true;\n    }\n  }\n\n  getCell(colIndex) {\n    return this.cells[colIndex];\n  }\n}\n\nexport default Row;\n","import ScreenComponent from './ScreenComponent';\n\nclass RowHeader extends ScreenComponent {\n  constructor(index, rowIndex, sheet, x, y, width, height, options) {\n    super(sheet, x, y, width, height, options);\n\n    this.rowIndex = rowIndex;\n\n    Object.assign(this, {\n      color: 'black',\n      backGroundColor: 'lightGray',\n      borderColor: 'darkGray',\n      borderWidth: 1\n    }, options);\n\n    this.textBufferCanvas = document.createElement('canvas');\n    this.textBufferContext = this.textBufferCanvas.getContext('2d');\n\n    this.textBufferCanvas.width = this.width * 2;\n    this.textBufferCanvas.height = this.height * 2;\n    this.textBufferCanvas.style.width = this.width;\n    this.textBufferCanvas.style.height = this.height;\n\n    this.textBufferContext.scale(2, 2);\n\n    this.textBufferContext.font = this.height * 0.8  + 'px Sans';\n    this.textBufferContext.fillStyle = this.color;\n    this.textBufferContext.textAlign = 'center';\n    this.textBufferContext.textBaseline = 'middle';\n\n    this.updateText(rowIndex + 1);\n  }\n\n  updateText(text) {\n    this.text = text;\n    this.textBufferContext.fillText(this.text, this.width / 2, this.height / 2);\n  }\n\n  draw() {\n    this.sheet.context.drawRect(this.x, this.sheet.scrollY + this.y, this.width, this.height, {\n      fillColor: this.backGroundColor,\n      borderColor: this.borderColor,\n      borderWidth: this.borderWidth\n    });\n\n    this.sheet.context.drawImage(this.textBufferCanvas, this.x, this.y + this.sheet.scrollY, this.width, this.height);\n  }\n}\n\nexport default RowHeader;\n","class ScreenComponent {\n  constructor(sheet, x, y, width, height) {\n    this.sheet = sheet;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  draw() {\n    // console.log(\"ScreenComponent:draw()\");\n  }\n\n  isVisibleOnScreen() {\n    return !(this.x + this.sheet.scrollX + this.width < 0 || this.x + this.sheet.scrollX > this.sheet.width ||\n      this.y + this.sheet.scrollY + this.height < 0 || this.y + this.sheet.scrollY > this.sheet.height);\n  }\n\n  isCollision(canvasX, canvasY) {\n    return canvasX > this.x + this.sheet.scrollX &&\n      canvasX < this.x + this.sheet.scrollX + this.width &&\n      canvasY > this.y + this.sheet.scrollY &&\n      canvasY < this.y + this.sheet.scrollY + this.height;\n  }\n}\n\nexport default ScreenComponent;\n","/**\n * ScrollBar reference jquery.scrollbar\n */\nclass ScrollBar {\n  constructor(target, sheet) {\n    this.wrapper = target;\n    this.sheet = sheet;\n    this.namespace = '.scrollbar_1';\n    this.scrollx = {};\n    this.scrolly = {};\n\n    var S = this,\n      sheet = this.sheet,\n      namespace = this.namespace,\n      s = { x: this.scrollx, y: this.scrolly };\n    // init scrollbars & recalculate sizes\n    $.each(s, function (d, scrollx) {\n\n      var scrollToValue = 0;\n\n      if (!scrollx.scroll) {\n\n        scrollx.scroll = S._getScroll('scroll' + d).addClass('scroll-' + d);\n\n        scrollx.scroll.addClass('scroll-element_arrows_visible');\n\n        scrollx.mousewheel = function (event) {\n\n          if (!scrollx.isVisible || (d === 'x' && S.isVerticalScroll(event))) {\n            return true;\n          }\n          if (d === 'y' && !S.isVerticalScroll(event)) {\n            s.x.mousewheel(event);\n            return true;\n          }\n\n          var delta = event.originalEvent.wheelDelta * -1 || event.originalEvent.detail;\n          var maxScrollValue = scrollx.size - scrollx.visible - scrollx.offset;\n\n          if ((delta > 0 && scrollToValue < maxScrollValue) || (delta < 0 && scrollToValue > 0)) {\n            scrollToValue = scrollToValue + delta;\n            if (scrollToValue < 0)\n              scrollToValue = 0;\n            if (scrollToValue > maxScrollValue)\n              scrollToValue = maxScrollValue;\n\n            S.scrollTo = S.scrollTo || {};\n          }\n\n          event.preventDefault();\n          return false;\n        };\n\n        scrollx.scroll\n          .on('MozMousePixelScroll' + namespace, scrollx.mousewheel)\n          .on('mousewheel' + namespace, scrollx.mousewheel)\n          .on('mouseenter' + namespace, function () {\n            // scrollToValue = c[scrollOffset]();\n            console.info('MozMousePixelScroll ...')\n          });\n\n        // handle arrows & scroll inner mousedown event\n        scrollx.scroll.find('.scroll-arrow, .scroll-element_track')\n          .on('mousedown' + namespace, function (event) {\n\n            if (event.which != 1) // lmb\n              return true;\n\n            var scrollForward = 1;\n\n            var data = {\n              \"eventOffset\": event[(d === 'x') ? 'pageX' : 'pageY'],\n              \"maxScrollValue\": scrollx.size - scrollx.visible - scrollx.offset,\n              \"scrollbarOffset\": scrollx.scroll.bar.offset()[(d === 'x') ? 'left' : 'top'],\n              \"scrollbarSize\": scrollx.scroll.bar[(d === 'x') ? 'outerWidth' : 'outerHeight'](),\n              \"scrollPostion\": (d === 'x') ? Math.abs(sheet.scrollX) : Math.abs(sheet.scrollY)\n            };\n            var scrollStep = 30, stepScrolling = true;\n\n            if ($(this).hasClass('scroll-arrow')) {\n              scrollForward = $(this).hasClass(\"scroll-arrow_more\") ? 1 : -1;\n              scrollStep = o.scrollStep * scrollForward;\n              scrollToValue = scrollForward > 0 ? data.maxScrollValue : 0;\n            } else {\n              scrollForward = (data.eventOffset > (data.scrollbarOffset + data.scrollbarSize) ? 1\n                : (data.eventOffset < data.scrollbarOffset ? -1 : 0));\n              scrollStep = Math.round(scrollx.visible * 0.75) * scrollForward;\n              scrollToValue = (data.eventOffset - data.scrollbarOffset -\n                (stepScrolling ? (scrollForward == 1 ? data.scrollbarSize : 0)\n                  : Math.round(data.scrollbarSize / 2)));\n              scrollToValue = data.scrollPostion + (scrollToValue / scrollx.kx);\n            }\n\n            var scrollToValue = stepScrolling ? -(data.scrollPostion + scrollStep) : scrollToValue;\n\n            S.doScroll(d, scrollToValue);\n\n            return S._handleMouseDown(null, event);;\n          });\n\n        // handle scrollbar drag'n'drop\n        scrollx.scroll.bar.on('mousedown' + namespace, function (event) {\n\n          if (event.which != 1) // lmb\n            return true;\n\n          var eventPosition = event[(d === 'x') ? 'pageX' : 'pageY'];\n          var initOffset = (d === 'x') ? sheet.scrollX : sheet.scrollY;\n\n          scrollx.scroll.addClass('scroll-draggable');\n\n          $(document).on('mousemove' + namespace, function (event) {\n            var diff = parseInt((event[(d === 'x') ? 'pageX' : 'pageY'] - eventPosition) / scrollx.kx, 10);\n            var offset_ = initOffset - diff;\n\n            S.doScroll(d, offset_);\n          });\n\n          return S._handleMouseDown(function () {\n            scrollx.scroll.removeClass('scroll-draggable');\n          }, event);\n        });\n      }\n    });\n\n    // calculate init sizes\n    $.each(s, function (d, scrollx) {\n      $.extend(scrollx, (d == \"x\") ? {\n        \"offset\": parseInt(Math.abs(sheet.scrollX), 10) || 0,\n        \"size\": sheet.getContentWidth(),\n        \"visible\": sheet.width\n      } : {\n          \"offset\": parseInt(Math.abs(sheet.scrollY), 10) || 0,\n          \"size\": sheet.getContentHeight(),\n          \"visible\": sheet.height\n        });\n    });\n\n    // calculate scroll size\n    $.each(s, function (d, scrollx) {\n\n      var cssOffset = (d === 'x') ? 'left' : 'top';\n      var cssFullSize = (d === 'x') ? 'outerWidth' : 'outerHeight';\n      var cssSize = (d === 'x') ? 'width' : 'height';\n      var offset = parseInt(sheet.scrollX, 10) || 0;\n\n      var AreaSize = scrollx.size;\n      var AreaVisible = scrollx.visible + offset;\n\n      var scrollSize = scrollx.scroll.size[cssFullSize]() + (parseInt(scrollx.scroll.size.css(cssOffset), 10) || 0);\n\n      scrollx.scrollbarSize = parseInt(scrollSize * AreaVisible / AreaSize, 10);\n      scrollx.scroll.bar.css(cssSize, scrollx.scrollbarSize + 'px');\n\n      scrollx.scrollbarSize = scrollx.scroll.bar[cssFullSize]();\n      scrollx.kx = ((scrollSize - scrollx.scrollbarSize) / (AreaSize - AreaVisible)) || 1;\n      scrollx.maxScrollOffset = AreaSize - AreaVisible;\n    });\n  }\n\n  _getScroll(scroll) {\n    var html = [\n      '<div class=\"scroll-element scroll-element_arrows_visible scroll-scrollx_visible scroll-scrolly_visible\">',\n      '<div class=\"scroll-element_corner\"></div>',\n      '<div class=\"scroll-arrow scroll-arrow_less\"></div>',\n      '<div class=\"scroll-arrow scroll-arrow_more\"></div>',\n      '<div class=\"scroll-element_outer\">',\n      '<div class=\"scroll-element_size\"></div>', // required! used for scrollbar size calculation !\n      '<div class=\"scroll-element_inner-wrapper\">',\n      '<div class=\"scroll-element_inner scroll-element_track\">', // used for handling scrollbar click\n      '<div class=\"scroll-element_inner-bottom\"></div>',\n      '</div>',\n      '</div>',\n      '<div class=\"scroll-bar\">', // required\n      '<div class=\"scroll-bar_body\">',\n      '<div class=\"scroll-bar_body-inner\"></div>',\n      '</div>',\n      '<div class=\"scroll-bar_bottom\"></div>',\n      '<div class=\"scroll-bar_center\"></div>',\n      '</div>',\n      '</div>',\n      '</div>'\n    ].join('');\n    scroll = $(html).appendTo(this.wrapper);\n    $.extend(scroll, {\n      bar: scroll.find('.scroll-bar'),\n      size: scroll.find('.scroll-element_size'),\n      track: scroll.find('.scroll-element_track')\n    });\n    return scroll;\n  }\n\n  doScroll(d, offset_) {\n    if (offset_ > 0) {\n      offset_ = 0;\n    }\n    if (d === 'x') {\n      if(this.sheet.getContentWidth() - Math.abs(offset_) < this.sheet.width){\n        offset_ = this.sheet.width - 50 - this.sheet.getContentWidth();\n      }\n      this.sheet.scrollX = offset_;\n      this.scrollx.scroll.bar.css('left', Math.abs(sheet.scrollX) * this.scrollx.kx + 'px');\n    } else {\n      if((this.sheet.getContentHeight() - Math.abs(offset_)) < this.sheet.height){\n        offset_ = this.sheet.height - 50 - this.sheet.getContentHeight();\n      }\n      this.sheet.scrollY = offset_;\n      this.scrolly.scroll.bar.css('top', Math.abs(sheet.scrollY) * this.scrolly.kx + 'px');\n    }\n  }\n\n  isVerticalScroll(event) {\n    var e = event.originalEvent;\n    if (e.axis && e.axis === e.HORIZONTAL_AXIS)\n      return false;\n    if (e.wheelDeltaX)\n      return false;\n    return true;\n  }\n\n  _handleMouseDown(callback_, event_) {\n\n    var namespace = this.namespace;\n\n    $(document).on('blur' + namespace, function () {\n      $(document).add('body').off(namespace);\n      callback_ && callback_();\n    });\n    $(document).on('dragstart' + namespace, function (event) {\n      event.preventDefault();\n      return false;\n    });\n    $(document).on('mouseup' + namespace, function () {\n      $(document).add('body').off(namespace);\n      callback_ && callback_();\n    });\n    $('body').on('selectstart' + namespace, function (event) {\n      event.preventDefault();\n      return false;\n    });\n\n    event_ && event_.preventDefault();\n    return false;\n  }\n\n}\n\nexport default ScrollBar;\n","import Context from './Context';\nimport Row from './Row';\nimport ColumnHeaderRow from './ColumnHeaderRow';\nimport ScrollBar from './ScrollBar';\nimport {CELL_WIDTH, CELL_HEIGHT, ROW_HEADER_WIDTH} from './constants';\n\nclass Sheet {\n  constructor(target, options) {\n    this.scrollY = 0;\n    this.scrollX = 0;\n\n    this.selectMinRowIndex = -1;\n    this.selectMaxRowIndex = -1;\n    this.selectMinColIndex = -1;\n    this.selectMaxColIndex = -1;\n\n    Object.assign(this, {\n      width: undefined,\n      height: undefined,\n      rowCount: 10,\n      colCount: 5,\n    }, options);\n\n    var canvas = document.createElement(\"canvas\");\n    target.appendChild(canvas);\n    \n    this.context = new Context(canvas, {\n      onMouseMove: this.mouseMove.bind(this),\n      onMouseDown: this.mouseDown.bind(this),\n      onMouseUp: this.mouseUp.bind(this),\n      onMouseClick: this.mouseClick.bind(this),\n      onScroll: this.scroll.bind(this),\n      width: this.width,\n      height: this.height\n    });\n    \n    //TODO: make target a div and have library create canvas element\n    //TODO: allow to fill size of div placed in\n    \n    //Column headerX\n    this.columnHeaderRow = new ColumnHeaderRow(this, 0, 0, this.rowCount);\n    \n    //Data rows\n    this.rows = [];\n    \n    let rowY = CELL_HEIGHT;\n    \n    for(let i = 0; i < this.rowCount; i++) {\n      this.rows.push(new Row(i, this, 0, rowY, this.colCount));\n      rowY += CELL_HEIGHT;\n    }\n    \n    this.mainLoop();\n    this.scrollBar = new ScrollBar(target, this, this.width, this.height);\n  }\n\n  mainLoop() {\n    this.draw();\n    requestAnimationFrame(this.mainLoop.bind(this));\n  }\n\n  mouseDown(x, y) {\n    if(this.columnHeaderRow.isCollision(x, y)) {\n      this.columnHeaderRow.mouseDown(x, y);\n    }\n    else {\n      for(let i = 0; i < this.rows.length; i++) {\n        if(this.rows[i].isCollision(x, y)) {\n          this.rows[i].mouseDown(x, y);\n        }\n      }\n    }\n  }\n\n  mouseMove(x, y) {\n    document.body.style.cursor = 'default';\n\n    if(this.columnHeaderRow.isCollision(x, y)) {\n      this.columnHeaderRow.mouseMove(x, y);\n    }\n    else {\n      for(let i = 0; i < this.rows.length; i++) {\n        if(this.rows[i].isCollision(x, y)) {\n          this.rows[i].mouseMove(x, y);\n        }\n      }\n    }\n  }\n\n  mouseUp(x, y) {\n    if(this.columnHeaderRow.isCollision(x, y)) {\n      this.columnHeaderRow.mouseUp(x, y);\n    }\n    else {\n      for(let i = 0; i < this.rows.length; i++) {\n        if(this.rows[i].isCollision(x, y)) {\n          this.rows[i].mouseUp(x, y);\n        }\n      }\n    }\n  }\n\n  mouseClick(x, y) {\n    for(let i = 0; i < this.rows.length; i++) {\n      if(this.rows[i].isCollision(x, y)) {\n        this.rows[i].mouseClick(x, y);\n      }\n    }\n  }\n\n  scroll(dx, dy) {\n    var scrollY = this.scrollY;\n    if(dy > 0) {\n      scrollY -= 5 * dy;\n    }\n    else if(dy < 0) {\n      if(scrollY <= -5 * -dy) {\n        scrollY -= 5 * dy;\n      }\n    }\n\n    this.scrollBar.doScroll('y', scrollY);\n\n    var scrollX = this.scrollX;\n    if(dx > 0) {\n      scrollX -= 5 * dx;\n    }\n    else if(dx < 0) {\n      if(scrollX <= -5 * -dx) {\n        scrollX -= 5 * dx;\n      }\n    }\n    this.scrollBar.doScroll('x', scrollX);\n  }\n\n  draw() {\n    //Background and border\n    this.context.drawRect(0, 0, this.width, this.height, {\n      borderColor: 'darkGray',\n      borderWidth: 3,\n      fillColor: 'lightGray'\n    });\n\n    //Header\n\n    //Rows\n    for(let i = 0; i < this.rows.length; i++) {\n      const row = this.rows[i];\n\n      if(row.isVisibleOnScreen()) {\n        this.rows[i].draw();\n      }\n    }\n\n    //Column headers\n    this.columnHeaderRow.draw();\n    this.context.drawRect(0, 0, ROW_HEADER_WIDTH, CELL_HEIGHT, {\n      borderColor: 'black',\n      borderWidth: 1,\n      fillColor: 'darkGray'\n    });\n\n    //Scroll bars\n\n    //Multiselect borderWidth\n    if(this.showMultiSelect) {\n      let minRow = this.rows[this.selectMinRowIndex];\n      let maxRow = this.rows[this.selectMaxRowIndex];\n\n      let x = minRow.cells[this.selectMinColIndex].x + this.scrollX;\n      let y = minRow.y + this.scrollY;\n\n      let width = 0;\n\n      for(let i = this.selectMinColIndex; i <= this.selectMaxColIndex; i++) {\n        width += minRow.cells[i].width;\n      }\n\n      let height = 0;\n\n      for(let i = this.selectMinRowIndex; i <= this.selectMaxRowIndex; i++) {\n        height += this.rows[i].height;\n      }\n\n      this.context.drawRect(x, y, width, height, {\n        borderColor: '#4285f4',\n        fillColor: 'rgba(236, 243, 255, 0.5)',\n        borderWidth: 2\n      });\n    }\n  }\n\n  resizeRow(rowIndex, delta) {\n    this.rows[rowIndex].height += delta;\n\n    for(let i = rowIndex + 1; i < this.rows.length; i++) {\n      this.rows[i].y += delta;\n    }\n  }\n\n  resizeCol(colIndex, newWidth) {\n    if(newWidth < 0) {\n      return;\n    }\n    \n    this.columnHeaderRow.resizeCol(colIndex, newWidth);\n\n    for(let i = 0; i < this.rows.length; i++) {\n      this.rows[i].resizeCol(colIndex, newWidth);\n    }\n  }\n\n  deselectAllCells() {\n    for(let i = 0; i < this.rows.length; i++) {\n      this.rows[i].deselectAllCells();\n    }\n  }\n\n  startMultiSelect() {\n    this.clearMultiSelect();\n    this.isMultiSelecting = true;\n    this.showMultiSelect = true;\n  }\n\n  endMultiSelect() {\n    this.isMultiSelecting = false;\n  }\n\n  clearMultiSelect() {\n    this.showMultiSelect = false;\n    this.selectMinRowIndex = -1;\n    this.selectMaxRowIndex = -1;\n    this.selectMinColIndex = -1;\n    this.selectMaxColIndex = -1;\n  }\n\n  multiSelectSize() {\n    return (this.selectMaxRowIndex - this.selectMinRowIndex + 1) * (this.selectMaxColIndex - this.selectMinColIndex + 1);\n  }\n\n  updateSelection(rowIndex, colIndex) {\n    if(this.isMultiSelecting) {\n      if(this.selectMinRowIndex == -1 || rowIndex < this.selectMinRowIndex) {\n        this.selectMinRowIndex = rowIndex;\n      }\n\n      if(this.selectMaxRowIndex == -1 || rowIndex > this.selectMaxRowIndex) {\n        this.selectMaxRowIndex = rowIndex;\n      }\n\n      if(this.selectMinColIndex == -1 || colIndex < this.selectMinColIndex) {\n        this.selectMinColIndex = colIndex;\n      }\n\n      if(this.selectMaxColIndex == -1 || colIndex > this.selectMaxColIndex) {\n        this.selectMaxColIndex = colIndex;\n      }\n\n      this.deselectAllCells();\n\n      for(let i = this.selectMinRowIndex; i <= this.selectMaxRowIndex; i++) {\n        this.rows[i].updateSelection(this.selectMinColIndex, this.selectMaxColIndex);\n      }\n    }\n  }\n  getLastRow(){\n    return this.rows[this.rows.length -1];\n  }\n  getCell(rowIndex, colIndex) {\n    return this.rows[rowIndex].getCell(colIndex);\n  }\n  getContentWidth(){\n    return this.columnHeaderRow.width;\n  }\n  getContentHeight(){\n    return this.getLastRow().y\n  }\n}\n\nexport {\n  Sheet\n};\n","export const ROW_HEADER_WIDTH = 40;\nexport const CELL_WIDTH = 70;\nexport const CELL_HEIGHT = 20;\n","const alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; //0 = A, 25 = Z\n\nexport const iToA = (i) => {\n  let current = i;\n\n  let a = \"\";\n\n  while(current > -1) {\n    let digit = current % 26;\n    a = alpha[digit] + \"\" + a;\n\n    //This is not a straight number base conversion, we need to\n    //treat A as\n    current = Math.floor(current / 26) - 1;\n  }\n\n  return a;\n}\n\nexport const aToI = (a) => {\n  let index = (alpha.indexOf(a[0]) + 1) * Math.pow(26, a.length - 1) - 1;\n\n  for(let i = a.length - 1; i > 0; i--) {\n    index += (alpha.indexOf(a[i]) + 1) * Math.pow(26, a.length - i - 1);\n  }\n\n  return index;\n};\n"],"sourceRoot":""}